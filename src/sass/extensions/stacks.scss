@use "../helpers" as *;

$-layout-opts: (hstack, vstack, zstack, grid);

$-justify-opts: (
	justify-stretch: stretch,
	justify-start: flex-start,
	justify-center: center,
	justify-end: flex-end,
	justify-baseline: baseline,
);

$-justify-self-opts: (
	justify-self-stretch: stretch,
	justify-self-start: flex-start,
	justify-self-center: center,
	justify-self-end: flex-end,
	justify-self-baseline: baseline,
);

$-align-opts: (
	align-stretch: stretch,
	align-start: flex-start,
	align-center: center,
	align-end: flex-end,
	align-baseline: baseline,
);

$-align-self-opts: (
	align-self-stretch: stretch,
	align-self-start: flex-start,
	align-self-center: center,
	align-self-end: flex-end,
	align-self-baseline: baseline,
);

// SwiftUI-style auto-centering is hard to faithfully simulate on the web.
// Several conditions must be met:
//
// - Stacks stretch
// - Stacks can be manually aligned
// - Stack children are centered
// - Stack children can be manually aligned
//
// Based on https://codepen.io/zaydek/pen/RwGZwjJ.
@mixin stacks($variants...) {
	@include variants($variants...) using ($v) {
		/*
		 * <layout>
		 */

		@if matches($v, core) {
			@each $opt in $-layout-opts {
				.#{$opt} {
					--dm-justify-self: stretch;
					--dm-align-self: stretch;
				}
			}
		}

		/*
		 * <hstack>
		 */

		#{variant(hstack, $v)} {
			display: flex;
			flex-direction: row;
			justify-content: center;
			justify-self: var(--dm-justify-self);
			align-items: center;
			align-self: var(--dm-align-self);
			min-width: min-content; // Needed for `overflow-x-scroll`
		}

		@if matches($v, core) {
			.hstack > * {
				--dm-spacer-min-width: var(--dm-space); // Reset
				--dm-space: 0; // Reset
			}
		}

		#{variant(hstack, $v)} > * + * {
			margin-top: 0; // Reset
			margin-left: var(--dm-space);
		}

		// `<spacer :empty>` and `<spacer :empty><element>` do not implement spacing.
		//
		// <element>
		// --------------- -> flex-basis: 0;
		// <spacer :empty> -> flex-basis: var(--dm-space);
		// --------------- -> flex-basis: 0;
		// <element>
		//
		#{variant(hstack, $v)} > .spacer:empty,
		#{variant(hstack, $v)} > .spacer:empty + * {
			margin-left: 0;
		}

		/*
		 * <vstack>
		 */

		#{variant(vstack, $v)} {
			display: flex;
			flex-direction: column;
			justify-content: center;
			justify-self: var(--dm-justify-self);
			align-items: center;
			align-self: var(--dm-align-self);
			min-width: auto; // Needed for `overflow-x-scroll`
		}

		@if matches($v, core) {
			.vstack > * {
				--dm-spacer-min-width: 0; // Reset
				--dm-space: 0; // Reset
			}
		}

		#{variant(vstack, $v)} > * + * {
			margin-left: 0; // Reset
			margin-top: var(--dm-space);
		}

		// `<spacer :empty>` and `<spacer :empty><element>` do not implement spacing.
		//
		// <element>
		// --------------- -> flex-basis: 0;
		// <spacer :empty> -> flex-basis: var(--dm-space);
		// --------------- -> flex-basis: 0;
		// <element>
		//
		#{variant(vstack, $v)} > .spacer:empty,
		#{variant(vstack, $v)} > .spacer:empty + * {
			margin-top: 0;
		}

		/*
		 * <... wrap>
		 */

		@each $mk, $mv in (wrap: wrap, wrap-reverse: wrap-reverse, wrap-none: nowrap) {
			#{variant($mk, $v)} {
				flex-wrap: $mv;
			}
		}

		/*
		 * <zstack>
		 */

		// Based on https://codepen.io/zaydek/pen/MWjEvee.
		@if matches($v, core) {
			.zstack {
				display: grid;
				justify-items: center; // NOTE: Use `justify-items` not `justify-content`.
				justify-self: var(--dm-justify-self);
				align-items: center;
				align-self: var(--dm-align-self);
				position: relative;
			}
			.zstack > * {
				grid-row-start: 1;
				grid-column-start: 1;
				grid-row-end: 1;
				grid-column-end: 1;
				z-index: 10;
			}
			.zstack > :nth-child(n + 2) {
				position: absolute;
			}
		}

		/*
		 * <... w-*>
		 *
		 * NOTE: Takes precedence over `align-self-*`.
		 */

		#{variant(w-auto, $v)} {
			--dm-justify-self: stretch;
			--dm-align-self: stretch;
			width: auto;
		}
		@each $rv in to-array(range(), min-content, max-content, 100%, 100vw) {
			#{variant(w-#{desc($rv)}, $v)} {
				--dm-justify-self: center;
				--dm-align-self: center;
				width: resolve($rv, rem);
			}
		}

		/*
		 * <... h-*>
		 *
		 * NOTE: Takes precedence over `align-self-*`.
		 */

		#{variant(h-auto, $v)} {
			--dm-justify-self: stretch;
			--dm-align-self: stretch;
			height: auto;
		}
		@each $rv in to-array(range(), min-content, max-content, 100%, 100vh) {
			#{variant(h-#{desc($rv)}, $v)} {
				--dm-justify-self: center;
				--dm-align-self: center;
				height: resolve($rv, rem);
			}
		}

		/*
		 * <... justify-*>
		 */

		@each $mk, $mv in $-justify-opts {
			#{variant($mk, $v)} {
				justify-content: #{$mv};
			}
		}

		/*
		 * <... justify-self-*>
		 */

		@each $mk, $mv in $-justify-self-opts {
			#{variant($mk, $v)} {
				justify-self: #{$mv};
			}
		}

		/*
		 * <... align-*>
		 */

		@each $mk, $mv in $-align-opts {
			#{variant($mk, $v)} {
				align-items: #{$mv};
			}
		}

		/*
		 * <... align-self-*>
		 */

		@each $mk, $mv in $-align-self-opts {
			#{variant($mk, $v)} {
				align-self: #{$mv};
			}
		}

		/*
		 * <... space-*>
		 */

		@each $rv in to-array(nrange(), limit(range(), null, 320)) {
			#{variant(#{n($rv)}space-#{abs($rv)}, $v)} > * {
				--dm-space: #{rem($rv)};
			}
		}

		/*
		 * <spacer>
		 */

		@if matches($v, core) {
			.spacer {
				flex: 1 0 var(--dm-space);
				min-width: var(--dm-spacer-min-width); // Needed for `overflow-x-scroll`
			}
			.spacer:first-child,
			.spacer:empty + .spacer:empty,
			.spacer:last-child {
				flex: 1 0 0;
				min-width: 0; // Needed for `overflow-x-scroll`
			}
		}
	}
}
