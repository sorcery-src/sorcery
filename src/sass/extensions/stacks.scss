@use "../configuration" as conf;
@use "../generators" as gen;
@use "../getters" as get;
@use "../mixins" as mix;
@use "../utils";

$-layout-opts: (hstack, vstack, zstack, grid);

$-justify-opts: (
	justify-stretch: stretch,
	justify-start: flex-start,
	justify-center: center,
	justify-end: flex-end,
	justify-baseline: baseline,
);

$-justify-self-opts: (
	justify-self-stretch: stretch,
	justify-self-start: flex-start,
	justify-self-center: center,
	justify-self-end: flex-end,
	justify-self-baseline: baseline,
);

$-align-opts: (
	align-stretch: stretch,
	align-start: flex-start,
	align-center: center,
	align-end: flex-end,
	align-baseline: baseline,
);

$-align-self-opts: (
	align-self-stretch: stretch,
	align-self-start: flex-start,
	align-self-center: center,
	align-self-end: flex-end,
	align-self-baseline: baseline,
);

$-wrap-opts: (
	wrap: wrap,
	wrap-reverse: wrap-reverse,
	wrap-none: nowrap,
);

// NOTE: Stacks do not use a compositional API because
// `justify-self` and `align-self` need to apply to non-stack elements.

// SwiftUI-style auto-centering is hard to faithfully simulate on the web.
// Several conditions must be met:
//
// - Stacks stretch
// - Stacks can be manually aligned
// - Stack children are centered
// - Stack children can be manually aligned
//
// Based on https://codepen.io/zaydek/pen/RwGZwjJ.
@mixin stacks($variants...) {
	@each $variant in $variants {
		/*
		 * <layout>
		 */

		// @if utils.matches($variant, core) {
		// 	@each $opt in $-layout-opts {
		// 		.#{$opt} {
		// 			--dm-justify-self: stretch;
		// 			--dm-align-self: stretch;
		// 		}
		// 	}
		// }

		/*
		 * <hstack>
		 */

		@if utils.matches($variant, core) {
			.hstack > * {
				--dm-spacer-min-width: var(--dm-space); // Reset
				--dm-space: 0; // Reset
			}
		}

		.hstack {
			@include mix.variants($variant) {
				display: flex;
				flex-direction: row;
				// justify-self: var(--dm-justify-self);
				justify-content: center;
				// align-self: var(--dm-align-self);
				align-items: center;
				min-width: min-content; // Needed for `overflow-x-scroll`
			}
		}

		.hstack > * + * {
			@include mix.variants($variant) {
				margin-top: 0; // Reset
				margin-left: var(--dm-space);
			}
		}

		// `<spacer :empty>` and `<spacer :empty><element>` do not implement spacing.
		//
		// <element>
		// --------------- -> flex-basis: 0;
		// <spacer :empty> -> flex-basis: var(--dm-space);
		// --------------- -> flex-basis: 0;
		// <element>
		//
		.hstack > .spacer:empty,
		.hstack > .spacer:empty + * {
			@include mix.variants($variant) {
				margin-left: 0;
			}
		}

		/*
		 * <vstack>
		 */

		@if utils.matches($variant, core) {
			.vstack > * {
				--dm-spacer-min-width: 0; // Reset
				--dm-space: 0; // Reset
			}
		}

		.vstack {
			@include mix.variants($variant) {
				display: flex;
				flex-direction: column;
				// justify-self: var(--dm-justify-self);
				justify-content: center;
				// align-self: var(--dm-align-self);
				align-items: center;
				min-width: auto; // Needed for `overflow-x-scroll`
			}
		}

		.vstack > * + * {
			@include mix.variants($variant) {
				margin-left: 0; // Reset
				margin-top: var(--dm-space);
			}
		}

		// `<spacer :empty>` and `<spacer :empty><element>` do not implement spacing.
		//
		// <element>
		// --------------- -> flex-basis: 0;
		// <spacer :empty> -> flex-basis: var(--dm-space);
		// --------------- -> flex-basis: 0;
		// <element>
		//
		.vstack > .spacer:empty,
		.vstack > .spacer:empty + * {
			@include mix.variants($variant) {
				margin-top: 0;
			}
		}

		/*
		 * <... wrap>
		 */

		// TODO: Extract?
		@each $mk, $mv in $-wrap-opts {
			.#{$mk} {
				@include mix.variants($variant) {
					flex-wrap: $mv;
				}
			}
		}

		/*
		 * <zstack>
		 */

		// Based on https://codepen.io/zaydek/pen/MWjEvee.
		@if utils.matches($variant, core) {
			.zstack {
				display: grid;
				justify-self: var(--dm-justify-self);
				justify-items: center; // NOTE: Use `justify-items` not `justify-content`.
				align-self: var(--dm-align-self);
				align-items: center;
				position: relative;
			}
			.zstack > * {
				grid-row-start: 1;
				grid-column-start: 1;
				grid-row-end: 1;
				grid-column-end: 1;
				z-index: 10;
			}
			.zstack > :nth-child(n + 2) {
				position: absolute;
			}
		}

		/*
		 * <... justify-*>
		 */

		// TODO: Extract?
		@each $mk, $mv in $-justify-opts {
			.#{$mk} {
				@include mix.variants($variant) {
					justify-content: #{$mv};
				}
			}
		}

		/*
		 * <... justify-self-*>
		 */

		// TODO: Extract?
		@each $mk, $mv in $-justify-self-opts {
			.#{$mk} {
				@include mix.variants($variant) {
					justify-self: #{$mv};
				}
			}
		}

		/*
		 * <... align-*>
		 */

		// TODO: Extract?
		@each $mk, $mv in $-align-opts {
			.#{$mk} {
				@include mix.variants($variant) {
					align-items: #{$mv};
				}
			}
		}

		/*
		 * <... align-self-*>
		 */

		// TODO: Extract?
		@each $mk, $mv in $-align-self-opts {
			.#{$mk} {
				@include mix.variants($variant) {
					align-self: #{$mv};
				}
			}
		}

		/*
		 * <... space-*>
		 */

		@each $rv in utils.list-of(get.nspaces(), get.spaces()) {
			.#{get.n($rv)}space-#{get.abs($rv)} > * {
				@include mix.variants($variant) {
					--dm-space: #{gen.rem($rv)};
				}
			}
		}

		/*
		 * <spacer>
		 */

		@if utils.matches($variant, core) {
			.spacer {
				flex: 1 0 var(--dm-space);
				min-width: var(--dm-spacer-min-width); // Needed for `overflow-x-scroll`
			}
			.spacer:first-child,
			.spacer:empty + .spacer:empty,
			.spacer:last-child {
				flex: 1 0 0;
				min-width: 0; // Needed for `overflow-x-scroll`
			}
		}
	}
}
