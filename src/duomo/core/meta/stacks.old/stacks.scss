@use "../../../helpers" as *;

@use "hstack" as *;
@use "vstack" as *;
@use "zstack" as *;

$-align-opts: (
	align-stretch: stretch,
	align-start: flex-start,
	align-center: center,
	align-end: flex-end,
	align-baseline: baseline,
);

$-align-self-opts: (
	align-self-stretch: stretch,
	align-self-start: flex-start,
	align-self-center: center,
	align-self-end: flex-end,
	align-self-baseline: baseline,
);

// NOTE: Does not implement variants.
@mixin spacer {
	.spacer {
		--unhidden: flex;
		> * {
			--unhidden: initial;
		}
	}

	// TODO: Add `min-content` polyfill for scrolling overflow.
	.spacer {
		flex: 1 0 var(--space);
		&:first-child,
		&:last-child {
			flex-basis: 0;
		}
	}
}

@mixin stacks($variants...) {
	@include hstack($variants...);
	@include vstack($variants...);

	@include variants($variants...) using ($v) {
		@each $mk, $mv in $-align-opts {
			#{variant($mk, $v)} {
				align-items: $mv;
			}
		}
		@each $mk, $mv in $-align-self-opts {
			#{variant($mk, $v)} {
				align-self: $mv;
			}
		}
		@each $rv in var-join(nrange(), range()) {
			#{variant("#{n($rv)}space-#{abs($rv)} > *", $v)} {
				--space: #{resolve($rv, rem)};
			}
		}
	}

	@include spacer;
	@include zstack($variants...);

	// Nested stacks that do not use an explicit `width` or `height`
	// should stretch. This enables stacks to:
	//
	// 1. Center children automatically.
	// 2. Stretch nested stacks.
	//
	// TODO
	.hstack:not([class^="w-"]):not([class*=" w-"]):not([class^="h-"]):not([class*=" h-"]),
	.vstack:not([class^="w-"]):not([class*=" w-"]):not([class^="h-"]):not([class*=" h-"]),
	.zstack:not([class^="w-"]):not([class*=" w-"]):not([class^="h-"]):not([class*=" h-"]) {
		align-self: stretch;
	}
}
