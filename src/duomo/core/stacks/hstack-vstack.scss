@use "../../helpers" as *;

@use "sass:list";

$-align-opts: (
	align-stretch: stretch,
	align-start: flex-start,
	align-center: center,
	align-end: flex-end,
	align-baseline: baseline,
);

$-align-self-opts: (
	align-self-stretch: stretch,
	align-self-start: flex-start,
	align-self-center: center,
	align-self-end: flex-end,
	align-self-baseline: baseline,
);

// SwiftUI-style auto-centering is hard to faithfully simulate on the web.
// Several conditions must be met:
//
// 1. Stacks stretch; children are centered
// 2. Fixed-size stacks center (overrides 1)
// 3. Stacks can be manually aligned (overrides 2)
//
// In order to faithfully simulate this logic using CSS, variables and
// properties are used together.
//
// Stacks stretch; children are centered (meets condition 1):
//
// .hstack,
// .vstack {
//   --dm-align-self: stretch;
//   align-self: var(--dm-align-self); // Stacks stretch
// }
//
// .hstack {
//   display: flex;
//   flex-direction: row;
//   justify-content: center;
//   align-items: center; // Children are centered
// }
//
// .vstack {
//   display: flex;
//   flex-direction: column;
//   justify-content: center;
//   align-items: center; // Children are centered
// }
//
// Fixed-size stacks center (meets condition 2):
//
// .w-#{$rv} {
//   --dm-align-self: center; // Overrides `--dm-align-self: stretch`
//   width: rem($rv);
// }
//
// .h-#{$rv} {
//   --dm-align-self: center;
//   height: rem($rv);
// }
//
// Stacks can be manually aligned (meets condition 3):
//
// .align-start {
//   align-items: flex-start; // Overrides `align-self: var(--dm-align-self)`
// }
//
// .align-end {
//   align-items: flex-end; // Overrides `align-self: var(--dm-align-self)`
// }

// Based on https://codepen.io/zaydek/pen/mdrRZpb.
@mixin hstack-vstack($variants...) {
	@include variants($variants...) using ($v) {
		@if matches($v, core) {
			.hstack {
				--dm-align-self: stretch;
				align-self: var(--dm-align-self);
			}
			.vstack {
				--dm-align-self: stretch;
				align-self: var(--dm-align-self);
			}
			// NOTE: Cannot be aligned.
			.zstack {
				align-self: stretch;
			}
			// NOTE: Cannot be aligned.
			.grid {
				align-self: stretch;
			}
		}

		/*
		 * <hstack>
		 */

		#{variant(hstack, $v)} {
			display: flex;
			flex-direction: row;
			justify-content: center;
			align-items: center;
			min-width: min-content; // For `overflow-x-scroll`
		}

		@if matches($v, core) {
			.hstack > * {
				--dm-spacer-min-width: var(--space); // Reset
				--space: 0; // Reset
			}
		}

		// Polyfill Flexbox gap.
		#{variant(hstack, $v)} > * + * {
			margin-top: 0; // Reset
			margin-left: var(--space);
		}

		// `<spacer :empty>` and `<spacer :empty><element>` do not implement spacing.
		//
		// /////////////// <- Implements spacing
		// <element>
		// /////////////// <- Does not implement spacing
		// <spacer :empty>
		// /////////////// <- Does not implement spacing
		// <element>
		//
		#{variant(hstack, $v)} > .spacer:empty,
		#{variant(hstack, $v)} > .spacer:empty + * {
			margin-left: 0;
		}

		/*
		 * <vstack>
		 */

		#{variant(vstack, $v)} {
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			min-width: auto; // For `overflow-x-scroll`
		}

		@if matches($v, core) {
			.vstack > * {
				--dm-spacer-min-width: 0; // Reset
				--space: 0; // Reset
			}
		}

		// Polyfill Flexbox gap.
		#{variant(vstack, $v)} > * + * {
			margin-left: 0; // Reset
			margin-top: var(--space);
		}

		// `<spacer :empty>` and `<spacer :empty><element>` do not implement spacing.
		//
		// /////////////// <- Implements spacing
		// <element>
		// /////////////// <- Does not implement spacing
		// <spacer :empty>
		// /////////////// <- Does not implement spacing
		// <element>
		//
		#{variant(vstack, $v)} > .spacer:empty,
		#{variant(vstack, $v)} > .spacer:empty + * {
			margin-top: 0;
		}

		/*
		 * <spacer>
		 */

		@if matches($v, core) {
			.spacer {
				flex: 1 0 var(--space);
				min-width: var(--dm-spacer-min-width); // For `overflow-x-scroll`
			}
			.spacer:first-child,
			.spacer:empty + .spacer:empty,
			.spacer:last-child {
				flex: 1 0 0;
				min-width: 0; // For `overflow-x-scroll`
			}
		}

		/*
		 * <... align-* align-self-*>
		 */

		// Escape hatch: `<hstack>` and `<vstack>` can simulate `align-items` and
		// `align-self` but requires more elements.
		//
		// `justify-content` and `justify-self` are not stamped out because
		// `<spacer>`s are preferred.
		//
		@each $mk, $mv in $-align-opts {
			#{variant($mk, $v)} {
				align-items: $mv;
			}
		}

		// Escape hatch: `<hstack>` and `<vstack>` can simulate `align-items` and
		// `align-self` but requires more elements.
		//
		// `justify-content` and `justify-self` are not stamped out because
		// `<spacer>`s are preferred.
		//
		@each $mk, $mv in $-align-self-opts {
			#{variant($mk, $v)} {
				align-self: $mv;
			}
		}

		/*
		 * <... space-*>
		 */

		@each $rv in var-join(nrange(), range()) {
			#{variant(#{n($rv)}space-#{abs($rv)}, $v)} > * {
				--space: #{rem($rv)};
			}
		}
	}
}
