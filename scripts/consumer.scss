@use "sass:list";
@use "sass:map";
@use "sass:string";

@use "../src/sass" as * with ($headless: true);

// TODO: Convert HSL back to RGB?

// Ex:
//
// has-suffix(16, px)   -> false
// has-suffix(16px, px) -> true
//
@function has-suffix($str, $end) {
	$str: "" + $str;
	$end: "" + $end;
	@return string.slice($str, 1 + string.length($str) - string.length($end)) == $end;
}

// Ex:
//
// $light: (
//   ui-app-color: color(black),
//   ui-app-bg: color(white),
// );
// $dark: (
//   ui-app-color: color(white),
//   ui-app-bg: color(black),
// );
// @include themes((
//   light: $light,
//   dark: $dark,
// ));
//
// -> :root {
// ->   --ui-app-color: hsl(0deg, 0%, 0%);
// ->   --ui-app-bg: hsl(0deg, 0%, 100%);
// ->   transition: var(--theme-transition);
// -> }
// -> [data-theme="dark"] {
// ->   --ui-app-color: hsl(0deg, 0%, 100%);
// ->   --ui-app-bg: hsl(0deg, 0%, 0%);
// -> }
// -> .ui-app {
// ->   color: var(--ui-app-color);
// ->   background-color: var(--ui-app-bg);
// ->   transition: var(--theme-transition);
// -> }
//
// TODO: Add support for `root-bg` and `border-color-default`?
// TODO: `data-theme` should be dynamic; change to `themes: (...)`?
//
// prettier-ignore
@mixin themes($theme-info) {
	// TODO: Assert `$light-ast` and `$dark-ast` are mirrors.
	$light:      map.get($theme-info, light);
	$dark:       map.get($theme-info, dark);
	$transition: map.get($theme-info, transition);

	$theme-transition: var(--theme-transition);
	@if $transition == false {
		$theme-transition: null;
	}

	$light-ast: parse-ast($light);
	:root {
		@each $mk, $mv in $light-ast {
			@each $info in $mv {
				--#{map.get($info, var)}: #{map.get($info, value)};
			}
		}
		transition: $theme-transition;
	}

	$dark-ast: parse-ast($dark);
	[data-theme="dark"] {
		@each $mk, $mv in $dark-ast {
			@each $info in $mv {
				--#{map.get($info, var)}: #{map.get($info, value)};
			}
		}
	}

	@each $mk, $mv in $light-ast {
		.#{$mk} {
			@each $info in $mv {
				#{map.get($info, property)}: var(--#{map.get($info, var)});
			}
			transition: $theme-transition;
		}
	}
}

$-legend: (
	bg: background-color,
	border-color: border-color,
	box-shadow: box-shadow,
	color: color,
	fill: fill,
	opacity: opacity,
	stroke: stroke,
);

// Parses a lightweight abstract syntax tree.
@function parse-ast($map) {
	$ast: ();
	@each $mk, $mv in $map {
		@each $tk, $tv in $-legend {
			@if has-suffix($mk, $tk) {
				$n: string.index($mk, $tk);
				$key: string.slice($mk, 1, $n - 2);
				$current: map.get($ast, $key);

				// prettier-ignore
				$ast: map.set(
					$ast,
					$key,
					list.append(
						if(not $current, (), $current),
						(
							var: $mk,      // -> app
							property: $tv, // -> background-color
							value: $mv,    // -> hsl(0deg, 0%, 100%)
						)
					)
				);
			}
		}
	}
	@return $ast;
}

// prettier-ignore
$light: (
	fti-app-bg: color(white),
	fti-app-shadow: (0 0 0 1px color(gray-200), shadow(xs), shadow(md)),
	fti-content-search-bar-bg: color(white),
	fti-content-card-bg: color(white),
	fti-sidebar-bg: color(white),
	fti-sidebar-preview-bg: color(white),
	fti-svg-color: color(black),
	fti-faded-svg-color: color(black, 0.5),
);

// prettier-ignore
$dark: (
	fti-app-bg: color(black),
	fti-app-shadow: (0 0 0 1px color(gray-200), shadow(xs), shadow(md)),
	fti-content-search-bar-bg: color(white),
	fti-content-card-bg: color(white),
	fti-sidebar-bg: color(white),
	fti-sidebar-preview-bg: color(white),
	fti-svg-color: color(black),
	fti-faded-svg-color: color(black, 0.5),
);

// prettier-ignore
@at-root {
	@include themes((light: $light, dark: $dark));
}
